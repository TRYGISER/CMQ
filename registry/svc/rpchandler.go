package svc

import (
	"context"
	"strings"

	"github.com/micro/go-micro/metadata"
	"github.com/micro/go-micro/util/log"
	opentracing "github.com/opentracing/opentracing-go"
	"github.com/pkg/errors"
	proto "github.com/tian-yuan/iot-common/iotpb"
)

type rpchandler struct {
}

func (h *rpchandler) Registry(ctx context.Context, req *proto.ConnectMessageRequest, rsp *proto.ConnectMessageResponse) error {
	// get tracing info from context
	md, ok := metadata.FromContext(ctx)
	if !ok {
		md = make(map[string]string)
	}
	var sp opentracing.Span
	wireContext, _ := opentracing.GlobalTracer().Extract(opentracing.TextMap, opentracing.TextMapCarrier(md))
	// create new span and bind with context
	sp = opentracing.StartSpan("Registry", opentracing.ChildOf(wireContext))
	// record request
	sp.SetTag("req", req)
	defer func() {
		// record response
		sp.SetTag("res", rsp)
		// before function return stop span, cuz span will counted how much time of this function spent
		sp.Finish()
	}()

	log.Infof("registry connect message, username : %s, client id : %s", req.Username, req.ClientId)
	// 1. update device info to mysql database and get guid from mysql database
	// Password hold "product_key:sign", sign is generated by device_name device_secret product_key
	info := strings.Split(string(req.Password), ":")
	if len(info) != 2 {
		rsp.Code = 400
		rsp.Message = "password must be contain product key and sign."
		return errors.New(rsp.Message)
	}
	guid, err := Global.DeviceSvc.Register(info[0], req.ClientId, info[1])
	if err != nil {
		rsp.Code = 600
		rsp.Message = err.Error()
		return err
	}
	sp.SetTag("guid", guid)
	rsp.Guid = guid
	rsp.Code = 200
	rsp.Message = "registry success."
	return nil
}
